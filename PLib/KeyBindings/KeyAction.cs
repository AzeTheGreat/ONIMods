/*
 * Copyright 2019 Peter Han
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

using Harmony;
using System;
using UnityEngine;

namespace PeterHan.PLib {
	/// <summary>
	/// Internally stores the parameters used for a key binding.
	/// </summary>
	internal sealed class KeyAction {
		/// <summary>
		/// Creates a KeyAction based on a PAction from other assemblies.
		/// </summary>
		/// <param name="action">The template action.</param>
		/// <returns>A KeyAction which wraps it.</returns>
		public static KeyAction Create(object action) {
			KeyAction result = null;
			try {
				var trAction = Traverse.Create(action);
				// Faster to do this once, than to use reflection on every access
				string actionID = trAction.GetProperty<string>("Identifier");
				LocString title = trAction.GetProperty<LocString>("Title");
				int id = trAction.GetProperty<int>("ID");
				if (id > 0 && !string.IsNullOrEmpty(actionID))
					// Good enough for now!
					result = new KeyAction(id, actionID, title, trAction);
			} catch (ArgumentException e) {
				PUtil.LogException(e);
			}
			return result;
		}

		/// <summary>
		/// The action identifier.
		/// </summary>
		public string Action { get; }

		/// <summary>
		/// The current key binding for this action.
		/// </summary>
		public PKeyBinding CurrentKey { get; private set; }

		/// <summary>
		/// The current key binding for this action.
		/// </summary>
		public PKeyBinding DefaultKey { get; private set; }

		/// <summary>
		/// Whether the key is currently active.
		/// </summary>
		public bool IsDown { get; set; }

		/// <summary>
		/// The action ID.
		/// </summary>
		public int ID { get; }

		/// <summary>
		/// The title of this key binding.
		/// </summary>
		public LocString Title { get; }

		/// <summary>
		/// The action triggered when the key is pressed.
		/// </summary>
		private readonly System.Action onKeyDown;

		/// <summary>
		/// The action triggered when the key is released.
		/// </summary>
		private readonly System.Action onKeyUp;

		/// <summary>
		/// Used to write back the actual key bindings when they change.
		/// </summary>
		private readonly Traverse[] writeBack;

		private KeyAction(int id, string action, LocString title, Traverse trAction) {
			if (id < 1)
				throw new ArgumentException("Invalid action ID");
			// Save the fields for back updates
			var pGamePadButton = trAction.Property("GamePadButton");
			var pKey = trAction.Property("Key");
			var pModifiers = trAction.Property("Modifiers");
			writeBack = new Traverse[] { pKey, pModifiers, pGamePadButton };
			Action = action ?? throw new ArgumentNullException("action");
			// Current value of the action becomes the default, then duplicate it
			DefaultKey = new PKeyBinding(pKey.GetValue<KKeyCode>(), pModifiers.
				GetValue<Modifier>(), pGamePadButton.GetValue<GamepadButton>());
			CurrentKey = new PKeyBinding(DefaultKey);
			ID = id;
			IsDown = false;
			onKeyDown = trAction.GetProperty<System.Action>("DoKeyDown");
			onKeyUp = trAction.GetProperty<System.Action>("DoKeyUp");
			Title = title ?? action;
		}

		/// <summary>
		/// Creates a serializable key binding.
		/// </summary>
		/// <returns>A key binding matching the current assignment of this action.</returns>
		public SerializedKeyBinding CreateBinding() {
			return new SerializedKeyBinding(Action, CurrentKey.Key, CurrentKey.Modifiers,
				CurrentKey.GamePadButton);
		}

		public override bool Equals(object obj) {
			return obj is KeyAction other && other.ID == ID && other.Action == Action;
		}

		public override int GetHashCode() {
			// Was auto generated by VS, please don't kill me
			return ID;
		}

		/// <summary>
		/// Loads the key binding from a saved custom key binding.
		/// </summary>
		/// <param name="binding">The key binding to set.</param>
		public void LoadFrom(SerializedKeyBinding binding) {
			CurrentKey.GamePadButton = binding.GamePadButton;
			CurrentKey.Key = binding.KeyCode;
			CurrentKey.Modifiers = binding.Modifiers;
		}

		public override string ToString() {
			return "{0} = {1}".F(CurrentKey, Action);
		}

		/// <summary>
		/// Invokes all handlers registered for key presses.
		/// </summary>
		public void TriggerKeyDown() {
			onKeyDown?.Invoke();
		}

		/// <summary>
		/// Invokes all handlers registered for key releases.
		/// </summary>
		public void TriggerKeyUp() {
			onKeyUp?.Invoke();
		}

		/// <summary>
		/// Updates the key bindings as seen by the original PAction creator.
		/// </summary>
		public void UpdateKeyBindings() {
			writeBack[0]?.SetValue(CurrentKey.Key);
			writeBack[1]?.SetValue(CurrentKey.Modifiers);
			writeBack[2]?.SetValue(CurrentKey.GamePadButton);
		}
	}

	/// <summary>
	/// A component which allows tracking and disposal of the current handler for the button
	/// in the key bindings menu.
	/// </summary>
	internal sealed class ActionContainer : MonoBehaviour {
		/// <summary>
		/// The action handler to be disposed.
		/// </summary>
		public System.Action OnClick { get; set; }
	}
}
